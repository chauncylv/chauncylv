Sunday, April 10, 2022
1.C++中的类可以看作C语言中struct的升级版，结构体是一种构造类型，可以包含各种成员，也可以通过定义结构体变量，每个变量拥有相同的性质；例如：

2.C++中的类也是一种构造类型，但是进行了一些扩展，类成员不但可以是变量，还可以是函数（部分教材将成员称为属性(Property)，将成员函数称为方法(Method))

C/C++生成可执行文件的过程相似：

C语言代码在不同的编译器中的后缀都是.c，但是C++语言在不同的编译器中后缀形式有很多类，例如：其中UNIX是昂贵的商业操作系统，初学者几乎使用不到，所以一般情况下为了标准的统一，我们都使用.cpp作为后缀


	一个中大型的软件往往由多名程序员共同开发，会使用大量的函数以及变量，难免会造成命名冲突，为了解决合作开发时的命名冲突问题，C++中引入了命名空间namespace的概念。
在下列代码中，“::”是一个全新的符号，称为“域解析操作符”
std::cout<<;
namespace中可以包含：变量、函数、类、typedef、#define等等，最后由{}包括起来

头文件和std命名空间
std: standard的缩写，全名为“标准命名空间”
·complex库：对复数进行操作的函数库
·fstream库：对文件进行操作的函数库
为了避免头文件重名,新版C++库也对头文件的命名做了调整，去掉了后缀.h，其中为了继承C语言中的库，去掉.h后还在头文件名称前面加上了字母c,例如：stdio.h变成了cstdio
	在C++的标准中，可以发现不带.h的库中的函数均不在std命名空间中；对于带.h的头文件，所有的符号都位于全局作用域。
C++变量定义的位置：
在C89标准中，所有局部变量都必须在第一条执行语句触发前定义，例如编译器VC6.0默认状态下是遵循C89的标准的，而在C99标准中则修改了这个规则，最明显的就是可以在for语句中定义局部变量，在循环结束后局部变量就被释放，可以在多个循环中定义同一个名称的局部变量。
const更像编译阶段的#define：
#define是在预处理阶段替换数据，而const则是在编译阶段替换数据。
const常量在一般情况下是不允许修改的，但是我们可以使用指针将其修改，例如：


C++中的const变量虽然会占用内存，也能用&获得它的地址，但是在使用时更像编译时期的#define,#define也是值替换，可见范围也仅限与当前文件。const定义的常量是有类型的，所以比起#define更加安全。
Monday, April 11, 2022
new 和 delete运算符简介:
	在C语言中，动态分配内存用malloc()函数，释放内存用free()函数，例如：

	在C++中这两个函数仍然可用，但是C++中新添加了两个关键词new和delete，例如：
	
	inline内联函数：
	函数是一个可以重复使用的代码块，CPU会一条条地执行其中的代码。为了消除函数调用时的时空的开销，C++提供了一种高效的方法，即在编译阶段将函数调用处用函数体代替，类似于C语言中的宏展开。（注意：要在函数定义处添加inline关键字，在函数申明处添加关键字编译器会忽略）一般将非常短小的函数申明为内联函数.inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。
	默认参数：
	在给定的作用域中只能指定一次默认参数。
	C++函数重载：
函数的重载规则：·函数名称必须相同
·参数列表必须不同（个数不同、类型不同、参数排列顺序不同）
·函数的返回类型可以相同也可以不同
·仅仅返回类型不同不足成为函数的重载
从重载决议（Overload Resolution）的角度来看，重载并不是仅仅语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。
类和对象：
创建对象在栈上分配内存，需要用&获取它的地址：

也可以在堆上创建对象：

在栈上创建出来的对象都有一个名字，比如stu，使用指针指向它并不是必须的。但是通过new创建出来的对象就不一样，它在堆上分配内存，因此是没有名字的，只能通过指针去定位。
栈内存是程序自动管理的，不能使用delete删除栈上的对象，堆内存由程序员管理的，对象使用完毕后可以使用delete去删除。
内存细解：
	
Sunday April 24, 2022
C++类的定义和对象的创建详解：
class只是一个模板(Template)，编译后不占内存怒空间，所以在定义类时不能堆成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
使用对象指针：

	‘::’ 域解析符（也称作用域运算符或作用域限定符）
浅谈类的封装:
根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数都建议声明为private，而只将允许通过对象调用的成员函数声明为public。

		C++函数的编译：
对函数重新命名的过程叫做名字编码(Name Mangling)，Name Mangling的算法是可逆的，即可以通过现有函数名计算得出新函数名，也可以通过新函数名逆向推演出原有函数名。只声明而不定义即可看到新函数名。
C++构造函数详解：
在创建对象时自动执行，这种特殊的成员函数就是构造函数(Constructor)

在栈上创建对象时，实参位于对象名后面，例如上例前者调用构造函数，在堆上创建对象，实参位于类名后面，例如上例后者。
构造函数必须是public的，否则创建对象时无法使用。当然，设置为private和protected也是没错的，但是没有任何意义。
栈和堆的区别：
·管理方式不同：栈由编译器自动管理，无需程序员手动控制；堆产生和释放由程序员控制；
·空间大小不同，栈的空间有限；堆内存可达4G；
·能否产生碎片不同：栈不会产生碎片，因为栈是先进后出的队列；堆容易产生碎片，多次的new和delete会造成内存的不连续，从而造成大量的碎片；
·生长方向不同：栈的生长方向是向上的，而堆则向下
构造函数的重载：
构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。
构造函数初始化列表：
构造函数中的一项重要功能时对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员进行变量一一赋值，还可以采用初始化列表。

初始化const成员变量：
初始化const成员变量的唯一方法就是使用初始化列表。例如VS/VC不支持变长数组，我们自定义了一个VLA类，用于迷你变长数组。

VLA类包含了两个成员变量，m_len和m_arr指针，需要注意的是m_len加了const修饰，只能使用初始化列表的方式赋值。
C++析构函数详解：
Destructor也是一种特殊的成员函数，没有放回值，不需要程序员显式调用，而析构函数的名字是在类名前面加一个“~”符号
C++对象数组：
C++允许数组的每个元素都是对象，这样的数组称为对象数组。
对象数组中的每个元素都要用构造函数初始化。具体那些元素用那些构造函数初始化，取决与定义数组时的写法。

C++成员对象和封闭类详解：
一个类的成员变量如果是另一个类的对象，就称为“成员对象”。包含成员对象的类叫做封闭类（enclosed class）
·成员对象的初始化：
创建封闭类的对象时，它包含的成员对象也需要被创建，这就会引发成员对象构造函数的调用。如何让编译器知道，成员对象到底是用那个构造函数初始化，这就需要借助封闭类构造函数的初始化列表。

·成员对象的消亡：
封闭类对象的生成时，先执行所有对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一直，与它们在构造函数初始化列表中出现的次序无关。
